//
//  Multistage PCY
//  3 Pass Multistage approach w/ bitmaps and efficient storage
//
//  Joel Rorseth 104407927
//  February 13, 2018
//

#include <iostream>
#include <fstream>
#include <sstream>
#include <utility>
#include <vector>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <bitset>

#define NUM_BUCKETS 100000

// Input file, retail.txt, is a big dataset with 88k rows. Each row is a
// basket with some number of elements, encoded as integers. Rows are sorted.


// Write the pairs and frequencies to a space delimited text file
void write_pairs(const std::map<std::pair<int,int>,int> & pairs,
                 const std::string & filename, const int thresh) {
    
    auto new_filename = "./results/pcy/support" + std::to_string(thresh) + '_' + filename;
    std::ofstream out_file;
    out_file.open(new_filename);
    
    // Write {i,j,count(i,j)} all stored in 'pairs'
    for (const auto & p: pairs)
        out_file << p.first.first << ' ' << p.first.second << ' '
        << p.second << '\n';
    
    out_file.close();
}


int hash_fn_1(int i, int j) { return (i + j) % NUM_BUCKETS; }
int hash_fn_2(int i, int j) { return (i * j) % NUM_BUCKETS; }



// Pass 1 -- Make histogram of all items, hash all pairs to bucket
// Pairs are generated by basket. Note we keep count of bucket, not pairs
// Note: In-between-pass operations are performed (make freq bucket bit vector)

int pass_1(const std::string & filename, std::unordered_set<int> & freq_items,
               std::bitset<NUM_BUCKETS> & bit_vector, const int thresh) {

    std::ifstream in_file(filename);
    std::string line;
    int num, line_count;
    
    // Create temp (for Pass 1) map of items to their counts
    std::unordered_map<int, int> hist;
    
    // Create hash table, to be used only for Pass 1, then transformed
    // NOTE: Since buckets (hashes) are 0...NUM_BUCKETS, more efficient to use vector than hashtable
    std::vector<int> buckets(NUM_BUCKETS, 0);
    
    // NOTE: Using hash table, could have just as easily been...
    // std::unordered_map<int> buckets;

    // MARK: Pass 1
    while (std::getline(in_file, line)) {

        ++line_count;

        // Use stringstream to convert line into stream, read using >>
        std::stringstream ss(line);
        std::vector<int> basket;

        // Increment the element histogram
        while (ss >> num) {
            ++hist[num];
            basket.push_back(num);
        }

        // For each distinct pair in the current basket
        for (auto i = basket.begin(); i != basket.end(); ++i) {
            for (auto j = (i+1); j != basket.end(); ++j) {

                // Generate hash -- 1 of say 1000 unique hashes
                // This hash fn must be saved elsewhere
                int hash_val = hash_fn_1(*i, *j);

                // Increment count for bucket with that hash
                ++buckets[hash_val];
            }
        }
    }

    in_file.close();
    
    
    // MARK: In-between Pass 1 & 2
    
    // Calculate actual threshold using given percentage threshold
    auto support_cutoff = line_count * (((double) thresh) / 100.0);
    
    // Make a set of frequent items only
    for (const auto & item_pair: hist)
        if (item_pair.second > support_cutoff)
            freq_items.insert(item_pair.first);

    
    // Replace buckets w/ bit-vector where index is set when count > support thresh
    for (auto i = 0; i < buckets.size(); ++i) {
        if (buckets[i] >= support_cutoff) {

            // Bucket index i in the bit vector (size NUM_BUCKETS) is set
            bit_vector.set(i);
            //std::cout << i << ' ';
        }
    }
    
    return support_cutoff;
}



// Pass 2 -- Find pairs where i,j both freq, {i,j} hashes to freq bucket
// Use a second hash to make another hash table, returning bitmap in-between passes

void pass_2(const std::string & filename,
            const std::unordered_set<int> & freq_items,
            const std::bitset<NUM_BUCKETS> & pass1_bitmap,
            std::bitset<NUM_BUCKETS> & pass2_bitmap,
            int support_cutoff) {
    
    
    std::ifstream in_file(filename);
    std::string line;
    int num, line_count;
    
    // Second hash table, actually a vector since hash is 0...NUM_BUCKETS
    std::vector<int> buckets(NUM_BUCKETS, 0);
    
    // MARK: Pass 2
    while (std::getline(in_file, line)) {
        
        ++line_count;
        
        // Use stringstream to convert line into stream, read using >>
        std::stringstream ss(line);
        std::vector<int> basket;
        
        // Increment the element histogram
        while (ss >> num) {
            basket.push_back(num);
        }
        
        
        // For each distinct pair in the current basket
        for (auto i = basket.begin(); i != basket.end(); ++i) {
            for (auto j = (i+1); j != basket.end(); ++j) {
                
                // If pair hashes to freq bucket (Pass 1) and items are freq...
                if (freq_items.find(*i) != freq_items.end() &&
                    freq_items.find(*j) != freq_items.end() &&
                    pass1_bitmap[ hash_fn_1(*i, *j) ] == 1 &&
                    *i != *j) {
                    
                    // Use another hash function to conglomerate buckets
                    auto hash_val = hash_fn_2(*i, *j);
                    ++buckets[hash_val];
                }
            }
        }
    }
    
    in_file.close();
    
    // MARK: In-between Pass 2&3
    
    // Remove hash table and transform into bitmap for new bucket hashing
    for (auto i = 0; i < buckets.size(); ++i) {
        if (buckets[i] >= support_cutoff) {
            
            // Bucket index i in the bit vector (size NUM_BUCKETS) is set
            pass2_bitmap.set(i);
            //std::cout << i << ' ';
        }
    }
}



// Pass 3 -- Find final frequents pairs and their occurrence count
// Only keep {i,j} whom are both freq, and together hashed to freq buckets on Pass 1&2

void pass_3(const std::string & filename,
            const std::unordered_set<int> & freq_items,
            const std::bitset<NUM_BUCKETS> & pass1_bitmap,
            std::bitset<NUM_BUCKETS> & pass2_bitmap,
            const int thresh) {
    
    
    std::ifstream in_file(filename);
    std::string line;
    int num, line_count;
    
    // Final Pass 3 candidate pairs, in form of triples i,j,count
    std::map<std::pair<int,int>,int> candidate_pairs;
    
    // MARK: Pass 3
    while (std::getline(in_file, line)) {
        
        ++line_count;
        
        // Use stringstream to convert line into stream, read using >>
        std::stringstream ss(line);
        std::vector<int> basket;
        
        // Increment the element histogram
        while (ss >> num) {
            basket.push_back(num);
        }
        
        // For each distinct pair in the current basket
        for (auto i = basket.begin(); i != basket.end(); ++i) {
            for (auto j = (i+1); j != basket.end(); ++j) {
                
                // If pair hashes to freq bucket (Pass 1&2) and items are freq...
                // Important: Check bitmap using CORRESPONDING hash function
                if (freq_items.find(*i) != freq_items.end() &&
                    freq_items.find(*j) != freq_items.end() &&
                    pass1_bitmap[ hash_fn_1(*i, *j) ] == 1 &&
                    pass2_bitmap[ hash_fn_2(*i, *j) ] == 1 &&
                    *i != *j) {
                    
                    // Increase count in hashtable for the pair {i,j}
                    ++candidate_pairs[std::make_pair(*i, *j)];
                }
            }
        }
    }
    
    in_file.close();
    
    std::cout << "\nPAIR  \tOCCURRENCES\n";
    
    // Summarize final candidate pairs satisfying all Pass 3 conditions
    for (const auto & pair: candidate_pairs) {
        std::cout << pair.first.first << ',' << pair.first.second
            << "  \t" << pair.second << '\n';
    }
    
    // Uncomment to write results to file
    // write_pairs(candidate_pairs, filename, thresh);
}



// Simulation -- Invoke all passes sequentially
int main(int argc, char ** argv) {
    
    if (argc != 3) {
        std::cout << "Usage: " << argv[0] << " <input.txt> <support thresh %>\n";
        return 1;
    }
    
    const std::string filename{argv[1]};
    const int thresh_percent = std::stoi(argv[2]);

    // Freq items set and buckets bitmap, the input for Pass 2
    std::unordered_set<int> freq_items;
    std::bitset<NUM_BUCKETS> pass1_bitmap;
    
    // Pass 1: Get/set item counts / freq items, freq pairs and bitmap
    int thresh = pass_1(filename, freq_items, pass1_bitmap, thresh_percent);
    
    // Obtain bitmap for Pass 2
    std::bitset<NUM_BUCKETS> pass2_bitmap;
    pass_2(filename, freq_items, pass1_bitmap, pass2_bitmap, thresh);
    
    // Perform final pass using all bitmaps, frequent items
    pass_3(filename, freq_items, pass1_bitmap, pass2_bitmap, thresh_percent);
}
