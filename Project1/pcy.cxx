//
//  Multistage PCY
//
//  Joel Rorseth 104407927
//  February 7, 2018
//

#include <iostream>
#include <fstream>
#include <sstream>
#include <utility>
#include <vector>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <bitset>

#define NUM_BUCKETS 1000

// Input file, retail.txt, is a big dataset with 88k rows. Each row is a
// basket with some number of elements, encoded as integers.


int hash_fn_1(int i, int j) { return (i + j) % NUM_BUCKETS; }
int hash_fn_2(int i, int j) { return (i * j) % NUM_BUCKETS; }



// Pass 1 -- Make histogram of all items, hash all pairs to bucket
// Pairs are generated by basket. Note we keep count of bucket, not pairs
// Note: In-between-pass operations are performed (make freq bucket bit vector)

int pass_1(const std::string & filename, std::unordered_set<int> & freq_items,
               std::bitset<NUM_BUCKETS> & bit_vector, int thresh) {

    std::ifstream in_file(filename);
    std::string line;
    int num, line_count;
    
    // Create temp (for Pass 1) map of items to their counts
    std::unordered_map<int, int> hist;
    
    // Create temp (for Pass 1) vector to store counts for every hashable bucket
    // NOTE: Instead of using hash table, use vector since buckets are 0...NUM_BUCKETS
    std::vector<int> buckets(NUM_BUCKETS, 0);

    // MARK: Pass 1
    while (std::getline(in_file, line)) {

        ++line_count;

        // Use stringstream to convert line into stream, read using >>
        std::stringstream ss(line);
        std::vector<int> basket;

        // Increment the element histogram
        while (ss >> num) {
            ++hist[num];
            basket.push_back(num);
        }


        // For each distinct pair in the current basket
        for (auto i = basket.begin(); i != basket.end(); ++i) {
            for (auto j = (i+1); j != basket.end(); ++j) {

                // Generate hash -- 1 of say 1000 unique hashes
                // This hash fn must be saved elsewhere
                int hash_val = hash_fn_1(*i, *j);

                // Increment count for bucket with that hash
                ++buckets[hash_val];
            }
        }
    }

    in_file.close();
    
    
    // MARK: In-between Pass 1 & 2
    
    // Calculate actual threshold using given percentage threshold
    auto support_cutoff = line_count * (((double) thresh) / 100.0);
    std::cout << "Items must occur in " << support_cutoff << " baskets\n";
    
    //std::cout << "Done.\nUnique elements: " << hist.size()
    //<< "\nHashed buckets: " << buckets.size() << std::endl;
    
    
    // Make a set of frequent items only
    for (const auto & item_pair: hist)
        if (item_pair.second > support_cutoff)
            freq_items.insert(item_pair.first);

    
    // Replace buckets w/ bit-vector where index is set when count > support thresh
    for (auto i = 0; i < buckets.size(); ++i) {
        if (buckets[i] >= support_cutoff) {

            // Bucket index i in the bit vector (size NUM_BUCKETS) is set
            bit_vector.set(i);
            //std::cout << i << ' ';
        }
    }
    
    std::cout << std::endl;
    return support_cutoff;
}





// Pass 2 -- Find pairs where i,j both freq, {i,j} hashes to freq bucket
//

void pass_2(const std::string & filename,
            const std::unordered_set<int> & freq_items,
            const std::bitset<NUM_BUCKETS> & pass1_bitmap,
            std::bitset<NUM_BUCKETS> & pass2_bitmap,
            int support_cutoff) {
    
    
    std::ifstream in_file(filename);
    std::string line;
    int num, line_count;
    
    // Second hash table, actually a vector since hash is 0...NUM_BUCKETS
    std::vector<int> buckets(NUM_BUCKETS, 0);
    
    // MARK: Pass 2
    while (std::getline(in_file, line)) {
        
        ++line_count;
        
        // Use stringstream to convert line into stream, read using >>
        std::stringstream ss(line);
        std::vector<int> basket;
        
        // Increment the element histogram
        while (ss >> num) {
            basket.push_back(num);
        }
        
        
        // For each distinct pair in the current basket
        for (auto i = basket.begin(); i != basket.end(); ++i) {
            for (auto j = (i+1); j != basket.end(); ++j) {
                
                
                // If pair hashes to freq bucket (Pass 1) and items are freq...
                if (freq_items.find(*i) != freq_items.end() &&
                    freq_items.find(*j) != freq_items.end() &&
                    pass1_bitmap[ hash_fn_1(*i, *j) ] == 1 &&
                    *i != *j) {
                    
                    // Use another hash function to conglomerate buckets
                    int hash_val = hash_fn_2(*i, *j);
                    ++buckets[hash_val];
                }
            }
        }
    }
    
    in_file.close();
    
    // MARK: In-between Pass 2&3
    
    // Remove hash table and transform into bitmap for new bucket hashing
    for (auto i = 0; i < buckets.size(); ++i) {
        if (buckets[i] >= support_cutoff) {
            
            // Bucket index i in the bit vector (size NUM_BUCKETS) is set
            pass2_bitmap.set(i);
            //std::cout << i << ' ';
        }
    }
}



//
//

void pass_3(const std::string & filename,
            const std::unordered_set<int> & freq_items,
            const std::bitset<NUM_BUCKETS> & pass1_bitmap,
            std::bitset<NUM_BUCKETS> & pass2_bitmap) {
    
    
    std::ifstream in_file(filename);
    std::string line;
    int num, line_count;
    
    // Final Pass 3 candidate pairs, in form of triples i,j,count
    std::map<std::pair<int,int>,int> candidate_pairs;
    
    // MARK: Pass 3
    while (std::getline(in_file, line)) {
        
        ++line_count;
        
        // Use stringstream to convert line into stream, read using >>
        std::stringstream ss(line);
        std::vector<int> basket;
        
        // Increment the element histogram
        while (ss >> num) {
            basket.push_back(num);
        }
        
        
        // For each distinct pair in the current basket
        for (auto i = basket.begin(); i != basket.end(); ++i) {
            for (auto j = (i+1); j != basket.end(); ++j) {
                
                
                // If pair hashes to freq bucket (Pass 1) and items are freq...
                if (freq_items.find(*i) != freq_items.end() &&
                    freq_items.find(*j) != freq_items.end() &&
                    pass1_bitmap[ hash_fn_1(*i, *j) ] == 1 &&
                    pass2_bitmap[ hash_fn_2(*i, *j) ] == 1 &&
                    *i != *j) {
                    
                    // Increase count in hashtable for the pair {i,j}
                    ++candidate_pairs[std::make_pair(*i, *j)];
                }
            }
        }
    }
    
    in_file.close();
    
    // Summarize final candidate pairs satisfying all Pass 3 conditions
    for (const auto & pair: candidate_pairs) {
        std::cout << pair.first.first << ',' << pair.first.second
            << ": " << pair.second << '\n';
    }
}



// Simulation -- Invoke all passes sequentially
int main(int argc, char ** argv) {
    
    if (argc != 3) {
        std::cout << "Usage: " << argv[0] << " <input.txt> <support thresh %>\n";
        return 1;
    }
    
    const std::string filename{argv[1]};
    const int thresh_percent = std::stoi(argv[2]);

    // Freq items set and buckets bitmap, the input for Pass 2
    std::unordered_set<int> freq_items;
    std::bitset<NUM_BUCKETS> pass1_bitmap;
    
    // Pass 1: Get/set item counts / freq items, freq pairs and bitmap
    int thresh = pass_1(filename, freq_items, pass1_bitmap, thresh_percent);
    
    std::cout << std::endl;
    
    /*
    for (auto i = 0; i < pass1_bitmap.size(); ++i)
        if (pass1_bitmap[i])
            std::cout << i << ' ';
    
     */
    
    std::bitset<NUM_BUCKETS> pass2_bitmap;
    pass_2(filename, freq_items, pass1_bitmap, pass2_bitmap, thresh);
    
    pass_3(filename, freq_items, pass1_bitmap, pass2_bitmap);
    
    std::cout << std::endl;
}
